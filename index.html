<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Clock</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #111111;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <svg id="tree-svg" width="100%" height="100vh" preserveAspectRatio="xMidYMid meet">
        <g id="tree-container"></g>
    </svg>

    <script src="tree_clock.js"></script>
    <script>
        // Render function to create the tree
        function renderTree() {
            const svg = document.getElementById('tree-svg');
            const container = document.getElementById('tree-container');

            const width = window.innerWidth;
            const height = window.innerHeight;
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            const now = new Date();
            const current_time = {
                "hours": now.getHours(),
                "minutes": now.getMinutes(),
                "seconds": now.getSeconds()
            }

            // tree root
            const global_start = {
                x: width / 2,
                y: height / 2
            };

            // prime factors of 24, 60 and 60
            const factors = {
                "hours": [2, 2, 2, 3],
                "minutes": [2, 2, 3, 5],
                "seconds": [2, 2, 3, 5]
            };
            // array of arrays of the number of lines in each layer (calculated by running product of factors)
            const layer_lines = {
                "hours": factors["hours"].reduce((acc, curr) => {
                    const product = acc[acc.length - 1] * curr;
                    return [...acc, product];
                }, [1]).slice(1),
                "minutes": factors["minutes"].reduce((acc, curr) => {
                    const product = acc[acc.length - 1] * curr;
                    return [...acc, product];
                }, [1]).slice(1),
                "seconds": factors["seconds"].reduce((acc, curr) => {
                    const product = acc[acc.length - 1] * curr;
                    return [...acc, product];
                }, [1]).slice(1),
            };

            // we number all lines but we don't want to color only the last layer. Will refine later
            const line_num_offset = {
                "hours": 14,
                "minutes": 18,
                "seconds": 18
            }
            // Custom colors for each layer
            const colors = {
                "hours": ['#0B4D2C', '#137547', '#1B9C5F', '#23C277'], // green
                "minutes": ['#8B0000', '#B22222', '#DC143C', '#FF4500'], // red
                "seconds": ['#000080', '#0000CD', '#4169E1', '#1E90FF'], // blue
            };
            // it's just 24, 60 and 60 but calculated in a universal way
            const lines_num = {
                "hours": factors.hours.reduce((acc, curr) => acc * curr, 1),
                "minutes": factors.minutes.reduce((acc, curr) => acc * curr, 1),
                "seconds": factors.seconds.reduce((acc, curr) => acc * curr, 1)
            }
            const total_lines = Object.values(lines_num).reduce((acc, curr) => acc + curr, 0);

            const lines = [];

            const time_divisions = ['hours', 'minutes', 'seconds'];
            let start_angle = 0;
            for (const key of time_divisions) {
                const sector_part = lines_num[key] / total_lines;
                const end_angle = start_angle + 2 * Math.PI * sector_part;
                const branch_height = Math.min(width, height) * 0.15;

                lines.push(...tree_clock(
                    global_start,
                    start_angle,
                    end_angle,
                    branch_height,
                    factors[key]
                ).map(line => {
                    const isLastLayer = line[2] === factors[key].length - 1;
                    const lineNumber = line[3];

                    let highlight = false;
                    if (isLastLayer) {
                        highlight = lineNumber === current_time[key];
                    } else {
                        // const time_ratio = current_time[key] / lines_num[key];
                    }

                    const color = highlight ? 'white' : colors[key][line[2] % colors[key].length];

                    return [...line, color];
                }));

                start_angle = end_angle;
            }

            // Generate SVG markup
            const svgContent = lines.map(line => {
                const [start, end, layer, lineNumber, color] = line;
                return `<line 
                    x1="${start.x}" 
                    y1="${start.y}" 
                    x2="${end.x}" 
                    y2="${end.y}" 
                    stroke="${color}"
                    stroke-width="${1}"
                    stroke-linecap="round"
                    data-layer="${layer}"
                    data-line-number="${lineNumber}" />`;
            }).join('\n');

            container.innerHTML = svgContent;
        }

        // Initial render and handle window resize
        window.addEventListener('load', renderTree);
        window.addEventListener('resize', renderTree);

        // Set interval to re-render every second
        setInterval(renderTree, 1000);
    </script>
</body>

</html>